// Note that this module is meant for 4/N scan rate only, where N is the number of rows
// e.g: for 32 by 64, scan rate of 1:8 required
// e.g: for 16 by 32, scan rate of 1:4 required
// Will not work for regular Adafruit matrices with 2/N scanrate
module matrix_writer_4nscanrate #(
  // default: 16 by 32 LED matrix, separated into top-8 rows and bottom 8-rows
  // both halves row i are written together for all rows 0 to 15 in a rapid loop 
  ADDRESS_SIZE = 3 : ADDRESS_SIZE > 0, //width of the address field (ABCD signals for matrix_led) 
  MATRIX_WIDTH = 32 : MATRIX_WIDTH > 0, //number of LEDs per row in the matrix
  ROW_OFFSET = 4 : ROW_OFFSET > 0 // distance between parallel rows in both top half and bottom half
)(
    input clk,  // clock
    input rst,  // reset
    input data[6], // input data from a simple RAM [b1,g1,r1,b0,g0,r0], see sample data below
    input mapped_ram_column[$clog2(MATRIX_WIDTH)],
    
    output actual_col_index[$clog2(MATRIX_WIDTH*2)],
    
    // addresses to a simple RAM 
    output col_index[$clog2(MATRIX_WIDTH)],
    output row_index[ADDRESS_SIZE],
    
    // output to matrix 
    output red0,
    output green0, 
    output blue0,
    output red1,
    output green1,
    output blue1,
    output latch, 
    output blank, // also known as OE
    output sclk_out,
    output address[ADDRESS_SIZE], // address[ADDRESS_SIZE] is unused
    
    // for debug, you can delete this if not needed
    output debug[16]

    
  ) {
  
  sig ram_row_index[ADDRESS_SIZE];
  sig ram_row_index_half[ADDRESS_SIZE-1];
  sig ram_col_index[$clog2(MATRIX_WIDTH)]; 
  
  const DIV = 6; //slowdown speed of the CLK, suitable for 100MHz clock
            
  .clk(clk){
    .rst(rst){
          // state details
          // b01 && sclk == all0s && shifted_bit_counter < MATRIX_WIDTH: loading data to 64 shift registers, off shifter clock
          // b01 && sclk == half_value: on shifter clock 
          // b01 && sclk == all1s && shifted_bit_counter == c{1,MATRIX_WIDTHx{b0}}: latching, reset shifted_bit_counter, advance address, off shifter clock, go to b10
          // b10 && sclk == all1s: blank OFF, go to b01
          dff state[2]; //to remember whether loading or displaying 
          
      
          dff sclk_counter[DIV]; // clock to load shift register, whenever sclk_counter == DIVx{b1} that's the cycle of shift reg clk
      
          // our actual physical matrix width is twice the actual column of the matrix since the led is connected in zigzag pattern 
          dff led_bit_counter[$clog2(MATRIX_WIDTH*2)+1]; // counter to keep track which of the 64 bits of LED is currently loaded 
          
          // since our scan rate is 4/N where N is number of rows, we do not need all address bits 
          // eg: in 32x16 matrix, only A,B address is used and not C
          dff current_address[ADDRESS_SIZE-1](#INIT(0)); // pointer of the current row address of the matrix, used when LATCH is 1 OR BLANK = 0
          
          // registers to store data out
          dff rgb_data[6]; // b1g1r1b0g0r0
          dff sclk; // clk signal to shift register
          dff latch_blank[2]; // [0] MSB is latch value, [1] LSB is blank value
      
          // to transform or not transform 
          dff transform_row(#INIT(0));
          // when transform_row_counter reaches 111, add transform_row by 1 
          dff transform_counter[3](#INIT(0));
      
          dff debug_dff[16]; // register for debugging
            
    }
    
  }
  


  
  always {
  
    // output to address external simple ram 
    actual_col_index = led_bit_counter.q[$clog2(MATRIX_WIDTH*2)-1:0];
    ram_col_index = mapped_ram_column; // column changes per cycle to load row led (until 64)
    ram_row_index_half = (current_address.q+1);
    ram_row_index = ram_row_index_half + transform_row.q*ROW_OFFSET; // plus one because we are loading next row, while prev row is still being displayed
    col_index = ram_col_index;
    row_index = ram_row_index;
    

    
    // output to matrix
    red0 = rgb_data.q[0];// LSB
    green0 = rgb_data.q[1];
    blue0 = rgb_data.q[2];
    red1 = rgb_data.q[3];
    green1 = rgb_data.q[4];
    blue1 = rgb_data.q[5]; // MSB
    
    blank = latch_blank.q[0]; // LSB
    latch = latch_blank.q[1]; // MSB
    sclk_out = sclk.q;
    address = current_address.q;
   
    debug_dff.d = led_bit_counter.q;
    debug = debug_dff.q;
    
    // internal counter to keep track what value we should give to shift register's clock sclk
    sclk_counter.d = sclk_counter.q + 1; // increase shift register clock 
    
    
    if (state.q == b00){ // START state
      latch_blank.d = b01; // latch off, blank on, begin 
      current_address.d = (ADDRESS_SIZE-1)x{b1}; // start from the first row address (all 1s) 
      
      state.d = b01;
    }
    
    
    // loading data when sclk is all 0 
    if (sclk_counter.q == DIVx{b0} && state.q == b01 && led_bit_counter.q <= MATRIX_WIDTH*2){
      
      // off clock when changing data 
      sclk.d = 0;
      
      // load data for next column
      transform_counter.d = transform_counter.q + 1;
      if (&transform_counter.q){
        // flip toggle to transform col and row 
        transform_row.d = transform_row.q + 1;
      }
      
      // shift the index to go to next LED in the row 
      led_bit_counter.d = led_bit_counter.q + 1;
      
    }
    
    // data load to rgb_data, given by input 'data' from simple ram that's available from the previous cycle's address 
    // (the if clause directly above this)
    else if (sclk_counter.q == 1 && state.q == b01 && led_bit_counter.q <= MATRIX_WIDTH*2){
        // set reg reg to always store from ram
        rgb_data.d = data;    
    }
      
      
    
    // change rising clock for shift registers in matrix to load input data in the second half of sclk_counter cycle
    else if (sclk_counter.q == (DIV-1)x{b1} && state.q == b01){
      sclk.d = 1;
    }
    
    // if we have loaded all LEDs in the row, latch for 1 sclk_counter cycle 
    else if(sclk_counter.q == (DIV)x{b1} && state.q == b01 && led_bit_counter.q == c{b1, $clog2(MATRIX_WIDTH*2)x{b0}}){
      // change state 
      state.d = b10;

      latch_blank.d = b11; // latch on, blank on
      
      // advance row address
      current_address.d = current_address.q + 1; 
      
      sclk.d = 0; // off latch clock 
      led_bit_counter.d = 0; // reset shift bit counter to start at 0 again
      
    }
    
   // in the next sclk_counter cycle, when sclk contains all 1, then DISPLAY
    else if(sclk_counter.q == (DIV)x{b1} && state.q == b10){
      latch_blank.d = b00; //latch off, blank off to display
      
      // change state to load again
      state.d = b01; 
     

    }


    
  }
}
